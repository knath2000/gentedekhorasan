# .clinerules - Luminous Verses (Expo App) - Project Intelligence

## Initial Observations & Patterns (2025-05-09)

### 1. Project Structure & Conventions:
-   **Expo Managed Workflow:** Project relies heavily on Expo's ecosystem and tools.
-   **Expo Router:** File-system based routing is a core navigation pattern.
    -   Tabs: `app/(tabs)/_layout.tsx` and `app/(tabs)/[screen].tsx`.
    -   Root: `app/_layout.tsx`.
-   **TypeScript:** Strictly typed codebase.
-   **Styling:** `styled-components` with a `ThemeProvider` is the chosen method for styling.
    -   Theme definition: `src/theme/theme.ts`.
    -   Typed theme: `src/styled.d.ts`.
-   **Component Organization:**
    -   Screens (route components) are in `app/`.
    -   Reusable UI components are in `src/components/`.
    -   Libraries/services (like Supabase client) are in `src/lib/`.
    -   Custom hooks are in `src/hooks/`.
-   **Asset Organization:** `assets/` directory with subfolders for `animations`, `fonts`, `images`.

### 2. Key Technologies & Integration Patterns:
-   **Supabase:** Used for dynamic data needs (planned: user accounts, bookmarks). Previously used for static Quran data.
    -   Client initialization: `src/lib/supabaseClient.ts`.
-   **Vercel Blob:** Primary store for static Quranic content (Arabic text, Surah list, translations) served as JSON files.
-   **Lottie Animations:**
    -   `lottie-react-native` for native.
    -   `@lottiefiles/dotlottie-react` for web.
    -   Current issue: Native Lottie animation plays once and freezes on Home screen.
-   **Custom Fonts:** Loaded via `expo-font` in the root layout.
-   **Audio Playback:** `expo-audio` is used, managed via `src/hooks/useQuranAudioPlayer.ts` which utilizes the library-provided `useAudioPlayer` hook. UI interaction (tap-to-play/pause) is handled in `src/components/VerseCard.tsx`.
-   **Metro Bundler Polyfills:** Critical for cross-platform compatibility of certain libraries. Configuration in `metro.config.js`.
-   **TypeScript DOM Lib:** `tsconfig.json` updated to include `"dom"` in `compilerOptions.lib` for web-specific typings (e.g., `HTMLInputElement` in `PlatformSlider.tsx`).
### 3. Development Workflow & Preferences:
-   **Memory Bank:** Essential for project continuity. All core documents are to be maintained.
-   **Iterative Development:** Features are built screen by screen. Bug fixing often involves iterative diagnosis.
-   **Cross-Platform First (with caveats):** Aim for maximum code sharing.
-   **Clear Documentation:** Emphasis on documenting current state, next steps, and decisions.
-   **Debugging:** Heavy reliance on `console.log`.

### 4. Tool Usage Patterns:
-   `write_to_file`: Primary tool for creating/updating documentation and code files.
-   `read_file`: Essential before any modification.
-   `apply_diff`: Can be problematic; `write_to_file` is a more reliable fallback. `apply_diff` requires exact string matches for search blocks.
-   `sequential-thinking` MCP: Used for planning complex multi-step tasks, especially debugging.
-   `execute_command`: Used for running scripts.

### 5. Potential Challenges / Areas to Watch:
-   **Cross-platform UI consistency.**
-   **Performance:** Lottie animations, data fetching.
-   **State Management Complexity:** As features grow.
-   **Metro Bundler Configuration.**
-   **Asynchronous Operations & State Sync:** Especially critical for audio. `useQuranAudioPlayer.ts` handles this.
-   **`expo-audio` Reliability:** The previous playback failure with `createAudioPlayer` was a major concern. The switch to the library-provided `useAudioPlayer` hook in `useQuranAudioPlayer.ts` is intended to address this.
-   **Accessibility Implementation:** Ensuring `AccessibilityInfo.announceForAccessibility` and correct ARIA props are used and effective across platforms.
## Layout & UI Development Patterns (2025-05-10)

### 6. Precise FlatList Sizing with Tab Bars & Safe Areas:
-   **Pattern:** For precise control over scrollable content boundaries with tab bars, direct height calculation using `Dimensions` and `useSafeAreaInsets` for the container is more reliable.

## Audio Playback & Asynchronous State Management Patterns (2025-05-11 to 2025-05-13)
## Audio Playback & UI Interaction Patterns (2025-05-14 Refactor)

### 7. Audio Hook (`src/hooks/useQuranAudioPlayer.ts`):
-   **Pattern:** Uses the library-provided `useAudioPlayer` hook from `expo-audio` to manage core audio state (loading, playing, duration, position, errors, etc.).
-   **Responsibilities:** Provides functions like `toggleAudio`, `stopAudio`, `seekAudio`, `setAutoplayEnabled`.

### 8. Stabilizing Callback References for `useEffect` Dependencies:
-   **Pattern:** Use `useCallback` with appropriate dependency arrays.

### 9. Managing Stale Closures and State with Refs:
-   **Pattern:** For stable callbacks needing current state, use a `useRef` updated by a separate `useEffect`.

### 10. Sequencing State Updates and Asynchronous Operations:
-   **Pattern:** Update UI-driving state immediately on user interaction, then call async functions. Hooks set "intent" state, initiate async ops, and rely on callbacks/status updates for definitive state changes.

### 11. `useEffect` Cleanup Functions:
-   **Vigilance Required:** Ensure cleanup functions correctly manage resources (e.g., audio player instances, event listeners, timers).

### 12. UI Component Responsibility for Audio Controls:
-   **`VerseCard.tsx`:**
    -   Displays verse, translation, and playback slider (if active).
    -   Handles tap-to-play/pause interaction directly on the card.
    -   Manages visual state for active/playing/paused states.
    -   Implements accessibility features (ARIA props, announcements, haptics).
-   **`AudioControlBar.tsx`:** Global controls (Stop, Skip Next), time display. (Remains largely unchanged by this refactor phase).
-   **`PlatformSlider.tsx`:**
    -   Provides a cross-platform slider component.
    -   Updated to accept and pass through accessibility props.

### 13. Tap-to-Play/Pause Interaction (`VerseCard.tsx` & `ReaderScreen.tsx`):
-   **Pattern:**
    -   `ReaderScreen.tsx` passes `onPress` (for selection) and `onTogglePlayback` (for play/pause) to `VerseCard.tsx`. Both are often mapped to the same handler (`handleVersePress` in `ReaderScreen`).
    -   `VerseCard.tsx`'s `handleCardPress` function determines if the card is already active.
        -   If active, it calls `onTogglePlayback`.
        -   If not active, it calls `onPress` (which typically makes the card active and may also trigger playback via `toggleAudio` in `ReaderScreen`).

### 14. Accessibility for Audio Components:
-   **`VerseCard.tsx`:**
    -   `accessibilityRole="button"`.
    -   Dynamic `accessibilityLabel` indicating verse number and playback state (e.g., "Verse 1, playing").
    -   `accessibilityHint` to guide users.
    -   `accessibilityState` including `selected`, `busy`, `checked` (for play/pause).
    -   `AccessibilityInfo.announceForAccessibility` for detailed state changes (loading, buffering, playing, paused, selected).
-   **`PlatformSlider.tsx`:**
    -   Passes `accessibilityLabel`, `accessibilityHint`, `accessibilityRole="adjustable"`, and `accessibilityValue` to the underlying native/web sliders.

## Data Migration & Static Asset Handling (Vercel Blob) (2025-05-13)

### 15. Static Data Strategy:
-   **Pattern:** Use static JSON files on Vercel Blob for Quranic text, translations, surah lists.

### 16. Migration Script Structure (Node.js):
-   **Pattern:** Scripts use `dotenv`, Supabase client, `@vercel/blob` client. Specify `access: 'public'`, `contentType: 'application/json; charset=utf-8'`, `addRandomSuffix: false`.

### 17. Environment Variable Consistency:
-   **Rule:** Ensure consistency for `VERCEL_BLOB_URL_BASE` etc., across `.env.local`, `app.json`, and scripts.

### 18. Application Service Layer Refactoring for Blob Data:
-   **Pattern:** Update services to `fetch` from Blob URLs and parse JSON.

### 19. Data Organization in Blob Storage:
-   **Pattern:** Hierarchical paths (e.g., `quran-text/arabic/[surahId].json`).

### 20. Idempotency and Error Handling in Migration Scripts:
-   **Rule:** Scripts should be idempotent and handle errors gracefully.

### 21. Shared UI Components for Consistency:
-   **Pattern:** Use shared components like `ScreenBackground.tsx`.

## `expo-audio` Playback Learnings (Pre-Refactor & Current)

### 15. Previous Issue: Playback Stalls with `createAudioPlayer`
-   **Observation:** The prior custom hook (`src/hooks/useAudioPlayer.ts`, now presumably deprecated or replaced by `useQuranAudioPlayer.ts`) using `expo-audio`'s `createAudioPlayer` consistently failed to start playback. `isLoaded` and `isPlaying` remained `false`.
-   **Resolution Path Taken:** The diagnostic plan involved testing the library-provided `useAudioPlayer` hook. The current `src/hooks/useQuranAudioPlayer.ts` successfully implements this, forming the basis of the current (refactored) audio system.

### 16. Current Approach: Library's `useAudioPlayer` Hook
-   **Pattern:** The `src/hooks/useQuranAudioPlayer.ts` now correctly uses `useAudioPlayer(source, updateInterval)` from `expo-audio`. This hook manages the `AudioPlayer` instance and its status.
-   **Benefit:** This approach is generally more stable and aligns with `expo-audio`'s intended usage, abstracting away some of the complexities of manual player creation and management.

### 17. TypeScript Configuration for Web (`tsconfig.json`):
-   **Rule:** When implementing web-specific features that use DOM elements (like `input type="range"` in `PlatformSlider.tsx`), ensure `"dom"` is included in the `compilerOptions.lib` array in `tsconfig.json` to provide correct typings for `HTMLInputElement` and other DOM APIs.

### 18. Tool Usage for Refactoring:
-   **Pattern:**
    -   `read_file` to understand existing components before modification.
    -   `apply_diff` or `write_to_file` for applying changes.
    -   Careful review of TypeScript errors post-modification to catch type mismatches or missing configurations (like the `tsconfig.json` `lib` update).

## Numeric Precision with Native Components (React Native Bridge) (2025-05-14)

### 19. Issue: "Loss of precision during arithmetic conversion"
-   **Observation:** Passing floating-point numbers (e.g., millisecond timestamps derived from seconds) to native UI components (like Sliders) or accessibility props (e.g., `accessibilityValue.min`, `.max`, `.now`) that expect integer values can cause crashes or warnings related to precision loss when these values cross the React Native bridge.
-   **Impact:** This primarily affects components that interact with native modules and can lead to unreliable behavior or app instability, especially noticeable with accessibility services.

### 20. Rule: Round Numeric Values Before Passing to Native Modules/Components
-   **Pattern:** Always use `Math.round()` (or `Math.floor()` / `Math.ceil()` if appropriate for the specific logic) on numeric values that:
    1.  Originate from calculations that might produce floats (e.g., `seconds * 1000`).
    2.  Are intended to be passed as props to native-backed UI components.
    3.  Are used in `accessibilityValue` or other accessibility props that are bridged to native.
-   **Implementation Points:**
    -   **Hooks:** Perform rounding within custom hooks that manage or calculate these values (e.g., `useQuranAudioPlayer.ts` now rounds `durationMillis` and `positionMillis`).
    -   **Component Props:** When passing props directly to native components (like `SliderIOS` in `PlatformSlider.tsx`) or to web equivalents that might have similar sensitivities (`input type="range"`), ensure the values are rounded.
    -   **Event Handlers:** When receiving values from native component events (e.g., slider `onValueChange`), if these values might be floats and are used in further calculations or state updates that feed back into native components, consider rounding them at the point of receipt or before use.
    -   **Utility Functions:** For common conversions (like `formatTime`), ensure the input is rounded if it's used in calculations that are sensitive to float vs. integer distinctions.

### 21. Defensive Programming in Consuming Components:
-   **Pattern:** Components that receive potentially problematic numeric props (e.g., `VerseCard.tsx` receiving `positionMillis`, `durationMillis`) should also apply `Math.round()` before using these values with child components (like `PlatformSlider`) or in internal calculations that feed into UI elements. This provides an extra layer of safety.

### 22. Logging for Precision Issues:
-   **Pattern:** In custom hooks or complex components dealing with these values, add specific `console.warn` or error logging if a precision-related error code or message is detected from underlying libraries (e.g., `expo-audio`). This logging should include the raw and rounded values to aid debugging. (Implemented in `useQuranAudioPlayer.ts`).

This file will be updated as new patterns, preferences, or critical project intelligence emerge.

## Robust Audio Playback & UI Synchronization Patterns (Expo Audio - 2025-05-14)

### 23. Rule: Event-Driven UI State for Audio
-   **Pattern:** UI state for audio playback (e.g., playing, paused, buffering, current time, slider position, verse highlighting) MUST be driven by actual events from the `expo-audio` player (specifically, `onPlaybackStatusUpdate` via the `useAudioPlayer` hook). Do not rely on optimistic updates or action intent alone. The reducer should transition to definitive states like 'playing' or 'paused' only *after* receiving confirmation from a player event.
-   **Rationale:** This ensures the UI is a source of truth reflecting the actual player status, preventing desynchronization issues like stuck buffering icons or inaccurate control states. (Reference: Expo community discussions, e.g., [Expo GitHub Issue #19788](https://github.com/expo/expo/issues/19788) regarding AV status, general React state synchronization best practices).

### 24. Rule: Mono-Instance 'Play-on-Create' Player Lifecycle
-   **Pattern:** Enforce a single, active `AudioPlayer` instance at any time. When a new verse/audio track is requested for playback:
    1.  Any existing player instance MUST be fully removed (including its event listeners and any associated timers like stall timers).
    2.  A new `AudioPlayer` instance is then created for the new source.
    3.  The `onPlaybackStatusUpdate` listener is attached to the new instance.
    4.  Playback is initiated immediately on the new instance (e.g., `await player.play()`).
-   **Rationale:** This 'play-on-create' or 'kill-and-replace' strategy prevents race conditions, stale listeners from previous players, multiple audio sources playing simultaneously, and simplifies state management by always dealing with a fresh player instance.

### 25. Rule: Reliable Toggle Logic (Play/Pause/Resume)
-   **Pattern:** Implement `toggleAudio` logic that correctly dispatches distinct actions based on the current player and UI state:
    -   If player is actively playing: Dispatch `REQUEST_PAUSE`.
    -   If player is loaded and paused (or UI state indicates paused/pausing for the same track): Dispatch `REQUEST_RESUME`.
    -   If player is in a loading or buffering state for the current track and user taps again: Dispatch `REQUEST_STOP` (to cancel current operation and reset).
    -   For new tracks or other unhandled states: Dispatch `REQUEST_PLAY` (which triggers the 'play-on-create' lifecycle).
-   **Rationale:** Avoid simple boolean flips for play/pause state. Using distinct actions and corresponding reducer states ensures clarity and correct handling of each user interaction and player state transition.

### 26. Learning: Resolving Stuck Buffering/Slider UI & State Desynchronization
-   **Observation:** Persistent 'buffering' UI (e.g., spinner not disappearing) or desynchronized controls (e.g., slider not updating, play/pause button showing wrong state) are typically symptoms of UI state not being correctly and unconditionally updated by player events.
-   **Solution:** The fix is to ensure that the `onPlaybackStatusUpdate` handler in the audio hook *always* dispatches an action to the reducer that sets the UI state to accurately reflect the player's current status (e.g., set to 'playing' when `event.isPlaying` is true and `event.isLoaded` is true, *regardless* of the previous UI state like 'buffering' or 'loading_requested'). The reducer case for this action should then directly set the `status: 'playing'`.

### 27. Learning: `expo-audio` Nuances & Best Practices
-   **Key Insight:** While `expo-audio`'s `useAudioPlayer` hook (or direct `createAudioPlayer` usage) provides the core player functionality, robust state synchronization with a React `useReducer` pattern and meticulous handling of the `onPlaybackStatusUpdate` event stream are critical for building a reliable and predictable audio user experience.
-   **Community Wisdom:** Adhering to patterns discussed in Expo forums and GitHub issues (such as ensuring event-driven state updates) is crucial for avoiding common pitfalls.

### 28. Pattern: Defensive Numeric Handling for Native Modules (Reiteration)
-   **Rule:** (This reiterates Rule #20 for emphasis in the audio context) Always use `Math.round()` on numeric values (especially time in milliseconds derived from seconds) *before* passing them as props to native UI components (like Sliders) or into `accessibilityValue` objects.
-   **Rationale:** Prevents "loss of precision during arithmetic conversion" errors when values cross the React Native bridge, ensuring stability and correct behavior of native elements and accessibility services.